# bit、数据类型及其运算

## bit和数据类型

### bit

### 数据类型

如果我们不仅定义了数值的表达方式（或编码方式），同时还定义了相关的操作方法，则在定义上称该表达方式为一种**数据类型**。

每个计算机指令集（ISA）都定义了一组数据类型及其相应的操作指令。本课程中我们将在算术运算中采用补码（2's Complement）编码表示正、负整数，在键盘输入和显示器输出的应用中，采用ASCII码表示字符。

除此之外，还存在很多其他数值表示方法。如“科学表示法”（scientific notation），即将数值621表示为$6.21\times 10^2$。现在，越来越多的计算机也开始支持这种表示方法，并提供相应的操作指令，我们称之为“浮点”（floating point）数据类型。

## 整数数据类型

### 无符号整数（unsigned integer）

我们可以将一个无符号整数表示为**一连串的二进制数字序列**（string of binary digits）。二进制补码的基（base）为2。

> 十进制数“329”：“位值法”（positional notation）表示方法，即“位置”决定其真实“数值”大小。不要看其中的数字“3”比数字“9” 小，但“3”的权重远比“9”更高，因为在这里“3”代表的是数值300，而“9”只代表9。

### 有符号整数（signed integer）

原码，反码（1's Complement），补码（2's Complement）。

> 有关负数表示方法的选择，应遵循使逻辑电路尽量简单的原则。计算机的ALU（算术逻辑运算单元）不知道也不关心它的两个输入数所代表的任何含义。它只会对两个二进制数做加法而不考虑其他（如正数、负数等因素）。这意味着我们必须为它选择一个合适的编码方式，以保证无论输入数是什么形式，它都将产生正确结果。——2's Complement selected.

## 进制转换

注意需要转换的二进制是原码还是补码表示法。

## bit的算术运算

### 加法和减法

### 符号拓展（Sign Extension, SEXT）

对于补码运算，在正数前面加0不改变值，在负数前面加1也不改变其值。

符号扩展主要应用在两个不同长度的二进制数相加的场合。

### 溢出

符号位被破坏

### 逻辑运算

## 其他数据类型

### 位矢量（bit vector）

假设存在n个单元，我们可以用一个n-bit的二进制数代表这n个单元。当某个单元空闲时，我们将相应的bit清0；当某个单元忙碌时，我们将相应的单元置1。我们称这个二进制数为“位矢量”。

### 浮点数

> 在LC-3中，整数的表示方法是16-bit补码，最高位可以看成符号位，剩下15位表示数值（绝对值）。
>
> LC-3能表示的数值范围是整数$-2^{15}\sim2^{15}-1$ （即$-32 768\sim32 767$），称LC-3的**数值表示精度**（precision）是15位，范围（range）是$2^{15}$。 

大多数的指令集都定义了一种或多种浮点数类型。其中之一通常被称做float类型，由32-bit组成，各bit的定义如下：
![image-20211112175519646](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211112175519646.png)

$N=(-1)^s\times1.F\times2^{E-127}$

注意指数部分是一个8位无符号数，标准规定不许取值$00000000$和$11111111$。

> 举例：用IEEE754标准表示$-6\frac58$。
>
> 1. 先表示成二进制数$-110.101$
> 2. 正则化处理$-1.10101\times2^2$
> 3. 符号位应当是1；指数应当是129，即$10000001$；尾数部分是$10101000..$。
> 4. 答案：1 10000001 10101000000000000000000

### ASCII码

### 十六进制计数

十六进制计数法用来替代二进制数字串的主要好处是方便记忆和使用。通过它，我们可以表示二进制数、浮点数、ASCII字 符序列或位矢量等各种数据类型。同时，这种记忆上的简易性，避免了因二进制数字串过长而引起的誊写错误。

# 数字逻辑

## MOS晶体管

### n型

![image-20211113082124010](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211113082124010.png)

对于n-MOS晶体管，如果在栅极接入2.9V电压，则在源极和漏极之间就会产生一条通路，这时候n-MOS晶体管就等于是一根连通线，专业术语上称“导通”或“闭路”。如果栅极电压是0V，则源极和漏极之间断开，我们称源极和漏极之间“断开”或“开路”。

> n-MOS管：高电平导通

### p型

和n型相反，低电平导通。（关键：栅极处的小圆圈指示低电平有效）

## 逻辑门

### 最简单的逻辑结构——非门（反相器）

![CMOS反相器](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211113151558884.png)

### 或非（NOR）门

![image-20211113151706651](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211113151706651.png)

### 或门：或非门+反相器

![image-20211113151731645](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211113151731645.png)

### 与门和与非门

![image-20211113084050871](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211113084050871.png)

## 复杂组合逻辑电路

### 译码器（decoder）

![image-20211113084349895](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211113084349895.png)

### 数据选择器（mux）

### 全加器（full adder）

### 可编程逻辑阵列（PLA）

## 存储单元

### RS锁存器（RS Latch）

### D锁存器

### 寄存器

![image-20211113084756476](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211113084756476.png)

## 内存

内存是由一定数目的“位置”组成的，其中每个“位置”可以被单独识别并独立存放1个数据。通常，我们称位置识别符为“地址"，又称存储在各个位置中的bit数目为“寻址能力”。

> “这个PC机有16MB（兆字节，MegaBytes）的内存”。这句话的意思是，该计算机系统中有16M（million）个内存位置，每个位置能容纳1个字节的信息。

### 寻址空间（address space）

我们称内存中可独立识别的位置总数为内存“寻址空间”。

表示地址的bit数如果是n，则我们可以识别$2^n$个存储位置。10-bit的地址可以标识1024个位置，即约等于1000。

### 寻址能力（addressability）

 寻址能力是指每个内存位置中包含的bit数目。大多数内存都是**字节寻址的**（byte-addressable）。

### 例子：一个$2^2\times 3$的内存

![image-20211113151811475](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211113151811475.png)

WE：是否允许写入

其中，$2^2$代表内存的地址空间大小为4，3代表寻址能力为3-bit宽度。即该内存的地址空间为4并按3位寻址。大小为$2^2$的内存地址需要2-bit来表示，寻址能力为3，意味着每个内存位置能存储3-bit信息。

内存访问需要对地址进行译码，即译码器将输入A[1:0]译码为4个输出线，即4根**字线**（word line）。 如图所示，内存中每个字线上包含3个bit（即这里定义的1个字）。读取内存时，只要设置地址值A[1:0]，则对应的字线被选中输出。

现在做个示例，若A[1:0] = 11，译码结果是最下面的字线被选中。假设该线上3个bit的内容为101，所以这3个bit与字线相与之后输出为101，进一步又输入给OR门。由于其他3个字线信号都为0，所以分别受AND门控制，OR门上其他3个输入必然为0。结果是数据线D[2:0]= 101， 也就是说，OR门输出的是位置3存储的内容。

内存的写操作过程与此类似。地址线A[1:0]的内容经过译码器之后，选中对应的字线，然后在WE信号的控制下，将$D_i[2:0]$上已设置的数据写入字线选中的门控锁存器中。

## 时序电路

### 状态

### 有限状态机

# 冯·诺依曼模型

## 基本部件

1946年，冯·诺伊曼提出了计算机处理或程序执行的基础模型，图中显示了该模型的基本组成。

![image-20211113154656772](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211113154656772.png)

冯·诺伊曼模型包括5个组成部分：内存memory、 处理单元processing unit、输入input、输出output、控制单元control unit。其中，内存负责存放程序，控制单元负责指令的有序执行。

### 内存

访问内存的第一步，是向内存提供被访问内存单元的地址。以读和写操作为例：

读操作。首先将被访问内存单元的地址放入CPU的内存地址寄存器（Memory Address Register, MAR），然后发送**读信号**通知内存。由此，内存将该单元中存放的数据传送至内存数据寄存器（Memory Data Register, MDR）。

写操作。首先将被访问内存单元的地址放入MAR寄存器，然后将要写入的数据放人MDR寄存器，最后向内存发送**写信号**。由此，MDR的内容被写入MAR指向的内存单元。

### 处理单元

ALU是**算术逻辑运算单元**的缩写。ALU所能完成的功能包括基本运算（如ADD、SUBTRACT）和基本逻辑操作（如按位AND、OR、NOT）等。

在LC-3中， 也包含了一个ALU单元，它可以完成
ADD、AND和NOT这三个基本操作。

ALU所能处理的量化大小（size of quantity）通常被称为该计算机的“字长”（word length），而量化的基本单位被称为一个**字**（word）。比如LC-3的ALU所能处理的量化大小是16-bit，所以我们称LC-3是一个16位的机器。

> 每类ISA都有自己的字长规定，这取决于该计算机的设计偏好。

通常，在设计中会为ALU在其附近配置少量存储器，以便它存放最近生成的中间计算结果。

临时存储器最常见的设计方式就是一组寄存器，其中每个寄存器的宽度应当是ALU处理的一个字。

在LC-3中，有8个这样的寄存器$R_1\sim R_7$，每个的宽度是16-bit。

### 输入和输出单元

### 控制单元

在计算机程序的逐步执行过程中，控制单元既负责控制程序执行过程的每一步，又负责控制其中每条指令执行过程的每一步。

控制单元中有几个特殊的寄存器：

1、指令寄存器（instruction register）， 保存的是正在被执行的那条指令。

2、PC寄存器（Program Counter, PC），用来指示下一条待处理的指令，控制单元专门准备了这个寄存器。

> 历史原因，该寄存器被命名为“程序计数器”（即PC寄存器），但它更合适的称法应该是“指令指针”（instruction pointer），因为该寄存器的内容实际上是指向下一条待处理指令的地址。

## 指令处理

冯·诺伊曼模型的核心思想是：程序和数据都是以bit流的方式存放在计算机内存中，程序在控制单元的控制下，依次完成指令的读取和执行。

### 指令

指令是计算机执行的最小单位。

指令本身由**操作码**和**操作数**两部分组成。

操作码表示该指令是做什么的，操作数表示该次操作的对象是哪些。

> **ADD指令**
>
> ADD指令需要3个操作数：两个相加数（源操作数）及一个求和结果（目的操作数）。
>
> 由于LC-3中总的寄存器数目是8，所以指令字段中，代表每个源或目的寄存器的位数是3位。因而，LC-3的ADD指令格式如下：
>
> ![image-20211113175748306](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211113175748306.png)
>
> bit[15:12] = 0001，代表ADD操作；
>
> bit[11:9] = 110，代表目的寄存器R6；
>
> bit[8:6] = 010，bit[2:0] = 110，代表源寄存器R2和R6；
>
> bit[5:3]的含义暂时不讲。
>
> 上述指令表示：R6←R2＋R6

> **LDR指令**
>
> LDR指令需要两个操作数。LD代表“load"，按照计算机语言，其意思是“从内存某个地方读取其中的内容，并将其内容存入某寄存器中”。两个操作数分别对应内存地址和目的寄存器。
>
> LDR中的“R”代表计算内存读取地址的机制（寻址模式），R代表的是“base+offset”模式。参考LC-3的LDR指令格式：
>
> ![image-20211113180233007](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211113180233007.png)
>
> LDR指令的4-bit操作码是“0110”。
>
> bit[11:9] = 010，代表内存读入数据所存放的目的寄存器R2。
>
> bit[8:6] = 011，代表偏移寄存器R3。
>
> bit[5:0] = 000110，代表基址值6。
>
> LC-3只支持“base+offset”一种寻址模式，其计算方法是：将bit[8:6]指定的寄存器的**内容**和bit[5:0]中的补码数值相加， 求得最终地址。
>
> 因而，本例的解读是“将R3的内容和立即数6相加，求得内存地址；然后将该地址指向的内存单元内容读入，并存放在R2寄存器中”。

### 指令周期

指令的处理过程是在控制单元的控制下，精确地、一步一步地完成的。 我们称这个执行的步骤顺序为指令周期（instruction cycle），其中的每一步称为节拍（phase）。一个指令周期包括6个节拍，**大多数**计算机的节拍设计都如此。

下面详细介绍指令周期的6个节拍

#### FETCH（取指令）

从内存中读取下一条待执行的指令，并将其装入控制单元的指令寄存器IR。

在冯·诺伊曼模型中指出，程序执行时整个程序的所有指令必须都已保存在内存中。所以要获取下条指令，前提是知道它在内存中的准确位置。PC负责的就是这个任务，它记录着下一条指令在内存中的地址。

FETCH节拍的具体工作描述：

(1)将PC的内容装入（load）MAR寄存器，注意这是一个**地址**。

(2)该地址对应内存单元的**内容**（即下一条指令）被装入MDR。

(3)控制单元将MDR内容装入IR寄存器。

之后，指令就进入译码节拍。但是，由于当前指令周期完成之后还将读入下一条指令，我们希望此时PC内容应修改为下一条指令的地址。所以，在当前FETCH节拍还需要补充一个动作，即修改PC寄存器的内容，我们称之为“PC增量”操作。（只要当前指令不去修改PC的内容）。

#### DECODE（译码）

译码操作的任务是分析、检查指令的类型，并确定对应的微结构操作细节。LC-3采用“4-16”译码器识别16种不同指令，也就是以IR[15:12]的4位操作码字段为输入。

#### EVALUATE ADDRESS（地址计算）

如果指令执行时存在地址计算操作，则在此节拍完成。以前面的LDR指令为例，它应将特定地址内存单元的内容读入寄存器R3，则地址值应该等于R3内容和立即数6之和，该求和操作就是在地址计算此节拍完成的。

#### FETCH OPERAND（取操作数）

该节拍负责读取指令处理所需要的源操作数。仍以LDR指令为例，该节拍包括两个子步骤：

(1)将之前地址计算节拍算出的地址值装入MAR寄存器；

(2)从MDR寄存器获取读自内存的源操作数。

#### EXECUTE（执行）

该节拍负责指令的执行操作，不同的操作码在该节拍的操作也多半不同。

#### STORE RESULT（存放结果）

这是指令执行的最后节拍。来自之前节拍的执行结果将被写入目的寄存器。

在此节拍完成之后，控制单元复位指令周期，即从取指令节拍重新开始。PC寄存器在上个指令周期已自动修改，即已指向下一条指令所在的地址。

> LC-3的ADD和LDR指令并不需要全部的6个节拍。如ADD指令不需要地址计算节拍，而LDR指令则不需要执行节拍。

## 改变执行顺序

下面介绍第三类指令，即控制指令（control instruction）， 其作用是改变程序的执行顺序。例如，循环反复地执行一组指令。

控制指令即在指令的执行节拍来修改PC的内容，覆盖之前取指令节拍时PC加1后的值。该控制指令执行完成后，在下一个指令周期开始时，计算机访问PC获得的地址值是由该控制指令在执行节拍换入的新地址值，而不是之前PC加1后的地址值，从而实现了改变程序的执行顺序的目的。

> **JMP指令**
>
> 如下所示是LC-3的JMP指令，假设这条指令放在x36A2处。
>
> ![image-20211113184155939](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211113184155939.png)
>
> 其中：
>
> bit[15:12] = 1100，代表JMP指令操作码；
>
> bit[8:6] = 011，代表R3寄存器，即其中存放了下一条指令地址的寄存器；
>
> 所以这条指令的译码结果是“将R3寄存器的内容在执行节拍装入PC寄存器”。换句话说，下一条要执行的指令地址来自R3寄存器。
>
> 首先在该指令执行之初，PC内容等于x36A2；在FETCH节拍整条JMP指令被读入IR寄存器，同时PC自动覆盖为x36A3，假设之前R3内容等于x5446，那么在EXECUTE节拍PC内容就被更换为x5446。这就导致了在下一个指令周期，被处理的指令来自地址x5446，而不是x36A3。

## 停机操作

# LC-3结构

下面将介绍一个“真实的”计算机LC-3，更确切地说，是介绍LC-3的指令集结构（ISA）。

## ISA

ISA定义了软件编程所需要的必要而完整的描述。换句话说，ISA向以机器语言编程的程序员提供有关控制机器所需要的所有必要信息。

ISA给出了内存组织方式、寄存器组、指令集（包括操作码、数据类型、寻址模式）等信息。

### 内存组织方式

LC-3的可寻址空间大小是$2^{16}=65536$，寻址（即读写）基本单位是16位。

> 65536大小的空间并不是全部用于内存。

由于LC-3中数据处理的基本单位是16位，所以我们在此称这16位为一个字（word），同时我们也称LC-3是一个**字寻址**（word-addressable）机器。

### 寄存器

由于从内存中获取数据的速度很慢（不止一个周期），所以LC-3和大多数的机器一样，还提供了临时存储空间，它们的访问速度是一个周期。

临时存储空间的最常见实现方式是寄存器，LC-3中提供了一组通用寄存器，其中的每个寄存器称为通用寄存器（General Purpose Register, GPR）。

寄存器和内存的特性是一样的：

- 记忆特性。即可以存储信息并可被再次读出。每个寄存器的存储大小是一个字。

- 独立寻址。每个寄存器必须有独立的惟一标识。LC-3中提供了8个GPR（意味着标识编号需要3位就足够了），用符号表示的话，就是R0，R1，…，R7，图中所示是LC-3寄存器组，有时我们又称之为寄存器文件，其中R0，…，R7的内容分别为1、3、5、7、-2、-4、-6和-8。

    ![image-20211115213327683](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211115213327683.png)

### 指令集

一条指令分为两个部分：操作码（做什么）和操作数（对谁操作）。

一个ISA（或体系结构）的指令集（instruction set）定义包括：操作码的集合、数据类型和寻址模式。其中寻址模式决定了操作数的存放位置。

![image-20211115213442632](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211115213442632.png)

上面是一条ADD指令，其操作码是ADD，寻址模式是**寄存器模式**（register mode）。操作码ADD的意思是请求计算机执行补码加法，而被操作对象（或数据）则来自通用寄存器。

### 操作码

LC-3的ISA结构定义了15条指令，每条指令对应一个操作码（指令的bit[15:12]）。

> 在LC-3中，操作码值1101没有定义，我们将其预留，以后再定义。

所有指令可以分为三类：运算（operate）、数据搬移（data movement）和控制（control）。

- 运算类指令负责处理信息；

- 数据搬移类指令则负责在内存和寄存器之间以及内存/寄存器和IO设备之间转移信息；

- 控制类指令负责改变指令执行的顺序，即它们能让程序随时跳转至另一个地方继续执行（而不是常规的顺序向下执行）。

### 数据类型

LC-3的ISA所支持的惟一数据类型：补码整数。

### 寻址模式

寻址模式是指**定义操作数位置**（或来源）的一种机制。

操作数可能存在的地方无非是以下三种之一：内存、寄存器或指令本身。其中，我们称存在于指令之中的操作数为**字面值**（literal）或**立即数**（immediate）。

> “字面值”说法是指该操作数是由指令的bit从字面上组成的，而“立即数"说法是指我们可以从指令中立即获得该操作数，即我们不需要再从别的地方去寻找该操作数。

LC-3共支持5种寻址模式：立即数、寄存器以及三种内存寻址模式，即相对寻址（PC-relative），间接寻址（indirect）、基址偏移（Base + offset）。

### 条件码（condition code）

几乎所有的ISA都具备**基于之前指令的执行结果来改变指令执行序列**的能力，其中的机制就是“条件码”。

LC-3具有三个1 bit寄存器，每当8个通用寄存器中**任意一个被修改或写入时**，三个单bit位就会发生对应变化（被置1或清零）。

三个位寄存器分别是N、Z和P，对应的意思是负数、零、正数。即每当任意GPR寄存器被写入时，**根据写入结果是负数、零或正数，分别设置三个条件位（0或1）**。

> 例如，如果写入GPR的结果是负数，则N位置1、Z和P清0，如果结果为0，则Z置1、P和N清0﹔如果写入结果是正数，则P位置1、N和Z清0。

我们称这三个单bit寄存器为**条件码**，因为控制指令可根据这些位的条件或状态决定执行顺序（或方向）是否改变。

## 操作指令

操作指令是处理数据的指令。

> 运算操作（如加/减/乘/除，即ADD/SUB/MUL/DIV）和逻辑操作（如与/或/非/异或，即AND/OR/NOT/XOR）都属于典型的操作指令。

LC-3只支持三种操作指令：ADD、AND和NOT。

### NOT指令

NOT指令（操作码=1001）是惟一的单操作数（unary）指令，即该类指令只需要单个源操作数。

NOT指令对16位源操作数做**按位取反**（bit-wise complement），并将结果存入目的寄存器。NOT指令对源和目的操作数的访问都是**寄存器寻址模式**。其中bit[8:6]是源寄存器，bit[11:9]是目的寄存器，bit[5:0]为全1。下面是一个例子。

![image-20211115215500113](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211115215500113.png)

如图所示是**数据通路**中执行NOT有关的关键部分。由于NOT是单操作数指令，所以ALU的输入只有A。ALU的信号表明是NOT操作（按位取反操作），源操作数是R5，运算结果写入R3寄存器。

<img src="C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211115215624119.png" alt="image-20211115215624119" style="zoom:50%;" />

### ADD指令和AND指令

ADD（操作码=0001）和AND（操作码=0101）都是双操作数（binary）指令，即它们都需要两个16位的源操作数。

ADD指令执行两个操作数的补码加法；AND指令对两个操作数的16个位中的每个bit对做按位与（bit-wise AND）操作。

同NOT一样，ADD和AND的源操作数之一（bit[8:6]）和目的操作数（bit[11:9]）都是寄存器寻址方式，运算结果写入目的寄存器。但ADD和AND指令的第二个源操作数寻址方式，则可以是寄存器方式或立即数方式（bit[5]指明是两种模式中的哪一种）。

bit[5]=0表明第二个源操作数是寄存器，bit[2:0]则代表该寄存器。这种情况下bit[4:3]=00。

![image-20211115220157601](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211115220157601.png)

如果bit[5]=1，则表明第二个操作数携带在指令之中，即对bit[4:0]做16位扩展之后再参加运算。图所示是执行指令“ADD R1, R4, #-2”的数据通路中的关键部件。

![image-20211115220255063](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211115220255063.png)

> 由于在ADD和AND指令中，只有bit[4:0]字段可以表示立即数，所以可表示的操作数（补码形式的）范围是有限的。

## 数据搬移指令

数据搬移指令的任务是在GPR和内存之间、寄存器和IO设备之间搬动数据。**这里暂时只讨论内存和寄存器之间的数据搬移。**

我们称数据从内存移入寄存器为装载（load），而从寄存器转入内存为存储（store）。注意，在两种情况下，数据源（或源操作数）的信息内容都不会因为此移动而改变，但目的操作数的内容将被刷新，即以前的内容被破坏了。

LC-3有7种搬移指令：LD、LDR、LDI、LEA、ST、STR和STI。

load和store指令的格式如下：

![image-20211115221731261](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211115221731261.png)

**数据搬移指令需要两个操作数：源和目的。**源是指将被搬移的数据，目的是指搬移的去处。两个操作数之一必然是寄存器，另一个则是内存或IO设备。如我们前面说过的，对于第二个操作数，这里只讨论内存。

bit[11:9]标识了操作数之一，即寄存器。

- 如果是load类型指令，则该字段代表DR（即Destination Register），即指令周期结束时，来自内存的内容将被写入该寄存器。

- 如果是store指令，则SR代表该寄存器内容将被写入内存。

bit[8:0]是“地址生成位”（address generation bit）。这意味着基于bit[8:0]的信息，可以计算出第二个操作数的16位地址。在LC-3中，有4种生成地址（或阐释bit[8:0]）的方法，也就是4种寻址模式。**采用哪种寻址模式是由操作码决定的**。

### PC相对寻址（PC-relative）

LD（opcode=0010）和ST（opcode=0011）采用PC相对寻址模式。

该寻址模式之所以这么命名，是因为bit[8:0]代表的是相对当前PC的偏移值。（还记得PC吗？是类似x3000的格式）

地址计算方法是：先将bit[8:0]内容做16位扩展，然后与PC值（**已增量**）相加。已增量PC的内容是当前指令在取指令节拍之后的值。

如果是load操作，计算出来的地址就是将被读取的内存单元的地址，读取结果被存入bit[11:9]指定的寄存器。

假设下列指令存放在地址x4018中，则被读取内存的地址是x3FC8，结果存放在R2中。

![image-20211115222442875](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211115222442875.png)

图所示是该指令执行的关键数据通路，其中标注了LD执行的三个步骤：

1. 将已增量PC（x4019，原先是x4018）与IR[8:0]内容（xFFAF，注意，这里要做数值拓展）相加，得出的结果（x3FC8）被装入MAR。
2. 读取地址为x3FC8的内存单元，其内容暂存入MDR（假设该单元的内容是5）
3. 将内容5装入R2，指令周期结束。

![image-20211115222907337](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211115222907337.png)

注意，内存地址的范围是受限的（不是整个地址空间的范围），即该地址只在相对当前LD或ST指令所在地址的+256和-255范围内（注意，在偏移量相加之前PC已被增量）；另外，指令中bit[8:0]的内容是一个有符号的数值（视bit[8]正负而定）。

### 间接寻址

LDI（opcode=1010）和STI（opcode=1011）指令采用的是间接寻址模式。

首先，采用和LD或ST一样的方法计算出一个地址。但是该地址不是提取或存入操作数所用的地址，事实上，该地址中存放的是另一个地址，后者才是load或store操作数的真正地址。

值得注意的是，这种方式下可寻址的范围是整个内存空间的任意地方（而不是LD和ST之PC相对模式下的+256~-255受限范围）。

### 基址偏移寻址

LDR（opcode=0110）和STR（opcode=0111）采用的是基址+偏移（Base + offset）的寻址模式。

之所以命名为“基址+偏移”模式，是因为操作数的地址是由**6-bit偏移量的符号扩展**和**基址寄存器的内容**相加而成的。6-bit的偏移量来源于指令的bit[5:0]字段，而基址寄存器则由指令的bit[8:6]字段标识。一个例子如下。

![image-20211115223433875](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211115223433875.png)

基址偏移寻址中，6-bit补码的表示范围为-32至+31之间，它必须先符号扩展为16位值，然后才能与基址寄存器相加。

### 立即数寻址

该模式只用于有效地址装载指令（load effective address, LEA）。LEA（opcode=1110）**将增量PC与bit[8:0]的符号扩展值相加**，并装入bit[11:9]指定的寄存器。

![image-20211115223707746](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211115223707746.png)

LEA指令的用途是对寄存器做初始化，即向寄存器装入一个地址值，且该地址是与当前指令很相近的一个地址。

## 控制指令

控制指令是指那些能够改变指令执行顺序的指令。LC-3有5种操作码可以打破这种顺序：条件跳转、无条件跳转、子程序（又称函数）调用、TRAP、中断返回。

这里我们讨论的主要内容是最常用的“条件跳转指令”，无条件跳转和TRAP指令也会有所介绍。其中，TRAP非常有用，因为它使得你可以在无需了解IO设备等复杂的计算机组织细节的情况下，与计算机交互信息，但是这里我们暂时还不介绍。

### 条件跳转指令

条件跳转指令（opcode=0000）的格式如下：

![image-20211115224225641](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211115224225641.png)

其中，bit[11]、[10]、[9]分别对应了之前说过的三个条件码，**所有**会对寄存器进行写操作的指令都会设置这三个条件码（之一），这些指令包括ADD、AND、NOT、LD、LDI、LDR和LEA。

使用方法：条件跳转指令通过对条件码的判断，来决定是否改变指令流，即是否改变正常的顺序（sequential）执行方式（在每条指令的取指令节拍，自动对PC++）。

在控制指令的指令周期中，取指令和译码节拍没有什么特殊的，取指令节拍之后，PC自动增量﹔地址计算节拍也与LD和ST指令相同，即将增量PC和指令bit[8:0]的16位符号扩展值相加求得地址。

而在执行节拍(EXECUTE)，处理器将检测某个条件码（对应指令中指定的条件码〉是否为1。

- 如果指令的bit[11]=1，则检查条件码N；
- 如果bit[10]=1，则检查条件码Z；
- 如果bit[9]=1，则检查条件码P。
- 如果bit[11:9]三个位全是0，则不检查任何条件码。

任意一个条件码的状态为1，都将使得PC内容重新修改，即将地址计算节拍生成的地址重新装入PC，而如果所有条件码的状态都为0，则PC内容保持不变（意味着在下一个指令周期，将顺序地读取下一条指令）。

不论在什么情况下，三个条件码中至少有一个是1，因为之前的寄存器装入内容可能是负数、0或正数（不存在其他的选择），换句话说，PC内容必然要更新，即装入在地址计算阶段得出的地址。

由于这种指令必定（或无条件）地要改变已有的PC内容，所以我们称这种检查所有条件状态位的指令为“无条件跳转”（unconditional branch）指令。

### 条件跳转示例

假设在地址x3100~x310B之间包含了12个整数，我们希望写个程序对它们求和。

![image-20211116130951211](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211116130951211.png)

初始化变量：

- 下一个待求和整数的**地址**（存放在R1中）
- 求和累计变量（存放在R3）
- 还未计算的整数数目（存放在R2）

这三个变量的初始化内容分别为：

- R1的初始值为第一个整数的地址
- R3初始化为0
- R2初始值为12

初始化之后，就开始求和过程。程序重复下面的过程：从12个整数中读取一个新的整数存入R4，然后加入R3。另外，在每执行一次ADD运算的同时，R1被增量（地址），指向下一个待求和整数，R2则被减量（减1）——告诉我们后面还有多少个整数有待计算。当R2变为0的时候，条件码位Z被置1，通过它我们知道事情已经完成。

![image-20211116131648307](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211116131648307.png)

- 程序起始于PC=x3000，此第一条指令的任务是，将地址值x3100装入R1寄存器（当前增量PC=x3001，PCoffset的符号扩展值=xOOFF，两者求和为x3100)。
- 随后，位于x3001的指令负责将R3清0。
- 位于x3002和x3003的指令负责给R2赋值(=12)，即被累计整数的数目。R2的任务是跟踪已有多少整数被加过了，该任务是通过位于地址x3008的指令在每次加法之后都对R2减1实现的。
- 位于x3004的是条件跳转指令。注意，该指令的bit[10]=1，即该指令要检查条件码Z。如果Z状态为1，就意味着之前的R2内容已被减为0了，工作结束了。如果Z状态为0，则意味着工作还没完成，还得继续。
- 位于x3005的是load类指令，将位于x3100的内容（第一个整数）装入R4。然后由位于x3006的指令将其加入R3。
- 位于x3007和x3008的指令负责一些常务性的收尾（bookkeeping）工作。x3007的指令对R1增量，使之指向下一个新的待加入整数（如地址x3101）；而x3008的指令对R2减量，用于记录还有多少个整数还未加入，同时该指令的执行还影响着条件码N、Z、P的状态值。
- 位于x3009的是一条无条件跳转指令，从其bit[11:9]全为1可以判断出来，。它向PC装入x3004。**该指令的执行不会影响条件码**，所以，之后将执行的条件跳转指令（x3004）将基于x3008的指令（改变条件码）。

值得注意的是，在转折点的指令执行顺序是x3008→x3009→x3004，但因为x3009的指令不影响条件码，因而事实上是x3008的指令结果决定了x3004指令的执行结果。x3008的指令之所以会改变条件码，是因为它对R2减1并写回R2。而x3004的条件跳转指令将检查该条件码位Z，如果Z被清0了，则PC不会被修改，即下一个指令周期的指令将从x3005继续获取。

> 值得一提的是，我们也可以在不使用任何控制指令的情况下，写出一个对12个整数求和的程序。我们仍然需要地址x3000的R1初始化指令，但不需要累计、变量初始化指令（x3001）和剩余整数数目变量初始化代码（x3002和x3003）。我们可以直接将x3100的内容装入R3，然后重复地（通过增量R1、将整数装入R4、将R4累加到R3）加入其他11个整数。在第12个整数加完之后，我们可以转入下一个任务。不幸的是，没有控制指令的新程序代码长达35行指令。如果我们要求100个整数的和，则这种不采用控制指令的写法编出的代码将长达299条指令（而原先的写法仍然是10条指令就可完成）。由此我们可以看出，由于控制指令具有改变指令执行顺序（或方向）的能力，就使得代码得以重用（reuse），总的代码长度变短了。

### 循环控制的方法

控制循环体执行轮数的方法有两种:

1. 采用计数器方法（如前所述）。如果需要将个循环执行n遍，我们只需要将计数器初始化为n。然后每执行一遍循环，就将计数器减1并判断其是否为0。如果计数器不为0，则重新设置PC至循环的入口，然后开始下一轮执行。
2. 采用“哨兵法”（sentinel）。这种方法在我们事先不知道要循环多少次的情况下特别有效。同“计数器方法”不同的是，哨兵法通过**对数据内容的判断**来控制循环是否继续。哨兵法的实现方法是：在被处理数据序列的尾部安放一个“哨兵”——即我们事先就知道绝对不会出现的数值。例如，如果我们正在对一个数字序列做求和运算，那么像“#”这样的符号就可以做哨兵。一旦发现哨兵，我们就知道任务该结束了。

### 哨兵法数组求和

![image-20211116153512584](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211116153512584.png)

若地址x3100~x310B之间存储的数据全部是正数，那么就可以任意选一个负数作为哨兵。假设在内存地址单元x310C放置了一个哨兵-1。

![image-20211116153634400](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211116153634400.png)

与前面的计数器方法一样，x3000的指令向R1装入第一个要加入的数据所在的地址，而x3001的指令将R3（累积和）初始化为0。
位于x3002的指令真正地将内存中（由R1指向）的数据装入R4。

如果此时装入的是哨兵数据，则条件码位N必然自动设置为1（因为正常数据都是正数，而哨兵数据是-1）。

位于x3003的条件跳转指令将专门检查N条件码位。如果N位为1，则设置PC为x3008；如果N位为0，R4必然包含了一个有效数字，则该数字被加入R3（x3004），R1增量指向下一个内存单元地址（x3005），R4装入下一个内存单元的内容（x3006），PC被装入x3003（即无条件跳转至x3003），开始下一轮执行（x3007）。

### JMP指令

条件跳转指令存在一个致命的局限性，**下一条指令所在位置不能超出可计算范围**。所谓的可计算范围是指PC寄存器和偏移量（bit[8:0]符号扩展值）的求和值。

由于bit[8:0]是补码表示，则9个bit的编码所表示的最大地址范围是距当前跳转指令前后+256至-255的地址空间。假如我们要执行的下一条指令是距离当前指令1000的位置，由于9个bit的字段装不下1000这么大的数值，那么条件跳转指令是无法完成这个跳转任务的。为此LC-3的指令集就提供了JMP指令（操作码=1100）。JMP指令格式如下：

![image-20211116153903588](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211116153903588.png)

JMP指令的任务就是将寄存器（bit[8:6]标识）的内容装入PC寄存器。假设JMP指令位于x4000，R2的内容为x6600，则JMP指令执行完毕后，下一条执行指令的地址则是x6600。JMP指令可以使得程序执行流跳转至内存空间的任意位置，其中的关键是寄存器（如R2）的宽度是16-bit，它可以表达内存空间的任意地址。

## 示例：字符数统计

从键盘读入一个字符，并统计一个文件中该字符出现的次数（计数值），最后在显示器上显示该计数值。

我们先做个假设：文件中任意字符的出现次数很小，即最多只有9次。之所以做这种假设，原因是我们希望避开做一个复杂转换：二进制数至ASCII码的转换。

下图是求解该问题的流程图，其中每个操作步骤都分别用英文和LC-3操作予以表示。

![image-20211116155449999](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211116155449999.png)

第一步是初始化工作，即对R0、R1、R2和R3等4个寄存器赋予初始值。R2代表字符出现的次数，初始值为0，R3是一个指针，指向文件中的下一个待读字符，初始值等于文件中第一个字符所在的地址；R0的内容则是待匹配的字符，R1的任务则是保存当前正在被读取的文件中的字符。

第二步是统计输入字符的出现次数。实现方法是逐个检查文件的每个字符，直到文件结束。循环体每执行一遍处理一个。这里我们将采用哨兵方法，即采用EOF（00000100）作为哨兵字符。

> 如果遇到的是文件结束符，即文件所有内容都已检查，则当前R2包含的就是键盘输入字符在文件中出现的次数。但这个计数值是二进制数，为了能在屏幕上显示，该数值必须转换成ASCII码。由于事先我们已假设计数值不会超过10，我们只需要在4-bit的计数值前面直接加上0011即可。

![image-20211116160020228](C:\Users\Sprout\AppData\Roaming\Typora\typora-user-images\image-20211116160020228.png)

具体执行方式见中文书P96。

